// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ===================================
// AUTHENTICATION & USER MANAGEMENT
// ===================================

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String    @unique
  emailVerified DateTime?
  image         String?
  password      String? // For email/password auth
  role          UserRole
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  accounts Account[]
  sessions Session[]
  seller   Seller?
  buyer    Buyer?
  supplier Supplier?

  @@index([email])
  @@index([role])
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

enum UserRole {
  SELLER
  BUYER
  SUPPLIER
  ADMIN
}

// ===================================
// SELLER MANAGEMENT
// ===================================

model Seller {
  id                    String   @id @default(cuid())
  userId                String   @unique
  companyName           String
  inviteCode            String   @unique @default(cuid())
  stripeAccountId       String?  @unique
  stripeOnboardingComplete Boolean @default(false)
  subscriptionStatus    SubscriptionStatus @default(TRIAL)
  subscriptionTier      SubscriptionTier   @default(STARTER)
  subscriptionId        String?  @unique
  currentPeriodEnd      DateTime?
  trialEndsAt           DateTime?
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  user                  User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  buyers                Buyer[]
  suppliers             Supplier[]
  campaigns             Campaign[]
  categories            Category[]
  sellerSettings        SellerSettings?
  usageLogs             UsageLog[]
  sellerSubscription    SellerSubscription?

  @@index([inviteCode])
  @@index([userId])
}

model SellerSettings {
  id                    String  @id @default(cuid())
  sellerId              String  @unique
  smsMarkup             Float   @default(0.20) // 20% markup on SMS costs
  emailMarkup           Float   @default(0.15) // 15% markup on email costs
  platformFeePercent    Float   @default(5.0)  // 5% platform fee on lead sales
  autoRechargeEnabled   Boolean @default(true)
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  seller Seller @relation(fields: [sellerId], references: [id], onDelete: Cascade)
}

model SellerSubscription {
  id                String   @id @default(cuid())
  sellerId          String   @unique
  stripeSubscriptionId String @unique
  plan              SubscriptionTier
  status            SubscriptionStatus
  currentPeriodStart DateTime
  currentPeriodEnd   DateTime
  cancelAtPeriodEnd  Boolean @default(false)
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  seller Seller @relation(fields: [sellerId], references: [id], onDelete: Cascade)

  @@index([sellerId])
}

enum SubscriptionStatus {
  TRIAL
  ACTIVE
  PAST_DUE
  CANCELED
  INCOMPLETE
  UNPAID
}

enum SubscriptionTier {
  STARTER
  GROWTH
  PROFESSIONAL
}

// ===================================
// BUYER MANAGEMENT
// ===================================

model Buyer {
  id                    String   @id @default(cuid())
  userId                String   @unique
  sellerId              String
  companyName           String
  priority              Int      @default(5) // 1-10 for weighted distribution
  walletBalance         Float    @default(0)
  stripeCustomerId      String?  @unique
  status                BuyerStatus @default(ACTIVE)
  autoRechargeEnabled   Boolean  @default(false)
  autoRechargeThreshold Float    @default(50)
  autoRechargeAmount    Float    @default(200)
  monthlySpendingLimit  Float?
  weeklySpendingLimit   Float?
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  user                  User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  seller                Seller                  @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  campaignSubscriptions CampaignSubscription[]
  leadAssignments       LeadAssignment[]
  transactions          Transaction[]
  paymentMethods        PaymentMethod[]
  notificationPreference NotificationPreference?

  @@index([sellerId])
  @@index([userId])
  @@index([status])
}

enum BuyerStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

model PaymentMethod {
  id            String   @id @default(cuid())
  buyerId       String
  stripePaymentMethodId String @unique
  brand         String
  last4         String
  expMonth      Int
  expYear       Int
  isPrimary     Boolean  @default(false)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  buyer Buyer @relation(fields: [buyerId], references: [id], onDelete: Cascade)

  @@index([buyerId])
}

// ===================================
// SUPPLIER MANAGEMENT
// ===================================

model Supplier {
  id              String   @id @default(cuid())
  userId          String   @unique
  sellerId        String
  name            String
  email           String
  apiKey          String   @unique @default(cuid())
  status          SupplierStatus @default(ACTIVE)
  categories      String[] // Array of category IDs they can submit leads for
  leadsDelivered  Int      @default(0)
  lastDeliveryAt  DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  seller Seller @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  leads  Lead[]

  @@index([sellerId])
  @@index([apiKey])
  @@index([userId])
}

enum SupplierStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

// ===================================
// CAMPAIGN MANAGEMENT
// ===================================

model Campaign {
  id                   String   @id @default(cuid())
  sellerId             String
  categoryId           String
  name                 String
  description          String?
  pricePerLead         Float
  distributionLogic    DistributionLogic @default(ROUND_ROBIN)
  allowStateSelection  Boolean  @default(true)
  status               CampaignStatus @default(ACTIVE)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  seller                Seller                  @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  category              Category                @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  subscriptions         CampaignSubscription[]
  leads                 Lead[]

  @@index([sellerId])
  @@index([categoryId])
  @@index([status])
}

enum DistributionLogic {
  ROUND_ROBIN         // Cycle through buyers
  WEIGHTED_ROUND_ROBIN // Use priority as weight
  WATERFALL           // Try highest priority first, then next if cap reached
  BROADCAST           // Send to all subscribed buyers
}

enum CampaignStatus {
  ACTIVE
  PAUSED
  ARCHIVED
}

model CampaignSubscription {
  id               String   @id @default(cuid())
  campaignId       String
  buyerId          String
  dailyCap         Int?     // Optional daily lead limit
  states           String[] // Empty array = all states (if allowed)
  status           CampaignSubscriptionStatus @default(ACTIVE)
  lastDistributedAt DateTime? // For round robin tracking
  waterfallPriority Int?     // For waterfall distribution (1 = highest)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  campaign        Campaign         @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  buyer           Buyer            @relation(fields: [buyerId], references: [id], onDelete: Cascade)
  leadAssignments LeadAssignment[]

  @@unique([campaignId, buyerId])
  @@index([campaignId])
  @@index([buyerId])
  @@index([status])
}

enum CampaignSubscriptionStatus {
  ACTIVE
  PAUSED
}

// ===================================
// CATEGORY MANAGEMENT
// ===================================

model Category {
  id          String   @id @default(cuid())
  sellerId    String
  name        String
  description String?
  fields      Json     // Array of field definitions: [{name, type, required, description}]
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  seller    Seller     @relation(fields: [sellerId], references: [id], onDelete: Cascade)
  campaigns Campaign[]
  leads     Lead[]

  @@unique([sellerId, name])
  @@index([sellerId])
}

// ===================================
// LEAD MANAGEMENT
// ===================================

model Lead {
  id          String   @id @default(cuid())
  campaignId  String
  supplierId  String
  categoryId  String
  data        Json     // Flexible JSON for all lead fields
  state       String?  // US State code (e.g., "CA", "NY")
  quality     LeadQuality @default(WARM)
  status      LeadStatus  @default(PENDING)
  receivedAt  DateTime @default(now())
  distributedAt DateTime?
  expiresAt   DateTime?

  campaign    Campaign         @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  supplier    Supplier         @relation(fields: [supplierId], references: [id], onDelete: Cascade)
  category    Category         @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  assignments LeadAssignment[]

  @@index([campaignId])
  @@index([supplierId])
  @@index([status])
  @@index([receivedAt])
  @@index([state])
}

enum LeadQuality {
  HOT
  WARM
  COLD
}

enum LeadStatus {
  PENDING       // Received but not yet distributed
  DISTRIBUTED   // Assigned to buyer(s)
  EXPIRED       // Past expiration date
  REJECTED      // Buyer rejected or refunded
}

model LeadAssignment {
  id                        String   @id @default(cuid())
  leadId                    String
  buyerId                   String
  campaignSubscriptionId    String
  price                     Float
  status                    LeadAssignmentStatus @default(DELIVERED)
  assignedAt                DateTime @default(now())
  deliveredAt               DateTime?
  viewedAt                  DateTime?
  rejectedAt                DateTime?
  rejectionReason           String?

  lead                Lead                  @relation(fields: [leadId], references: [id], onDelete: Cascade)
  buyer               Buyer                 @relation(fields: [buyerId], references: [id], onDelete: Cascade)
  campaignSubscription CampaignSubscription @relation(fields: [campaignSubscriptionId], references: [id], onDelete: Cascade)
  transaction         Transaction?

  @@index([leadId])
  @@index([buyerId])
  @@index([assignedAt])
}

enum LeadAssignmentStatus {
  DELIVERED
  VIEWED
  REJECTED
  REFUNDED
}

// ===================================
// PAYMENT & TRANSACTION MANAGEMENT
// ===================================

model Transaction {
  id                  String   @id @default(cuid())
  buyerId             String
  type                TransactionType
  amount              Float
  balanceBefore       Float
  balanceAfter        Float
  description         String
  leadAssignmentId    String?  @unique
  stripePaymentIntentId String? @unique
  metadata            Json?
  createdAt           DateTime @default(now())

  buyer          Buyer           @relation(fields: [buyerId], references: [id], onDelete: Cascade)
  leadAssignment LeadAssignment? @relation(fields: [leadAssignmentId], references: [id])

  @@index([buyerId])
  @@index([createdAt])
  @@index([type])
}

enum TransactionType {
  CREDIT          // Money added to wallet
  DEBIT           // Money deducted from wallet
  REFUND          // Lead refund
  AUTO_RECHARGE   // Automatic wallet top-up
}

// ===================================
// NOTIFICATION MANAGEMENT
// ===================================

model NotificationPreference {
  id              String   @id @default(cuid())
  buyerId         String   @unique
  emailOnLead     Boolean  @default(true)
  smsOnLead       Boolean  @default(false)
  webhookEnabled  Boolean  @default(false)
  webhookUrl      String?
  webhookSecret   String?  // For webhook signature verification
  emailNotifications Json? // {lowBalance: true, dailySummary: true, ...}
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  buyer Buyer @relation(fields: [buyerId], references: [id], onDelete: Cascade)

  @@index([buyerId])
}

model NotificationLog {
  id              String   @id @default(cuid())
  type            NotificationType
  recipient       String   // Email or phone number
  subject         String?
  content         String   @db.Text
  status          NotificationStatus @default(PENDING)
  provider        String   // "sendgrid", "twilio", "webhook"
  providerId      String?  // External ID from provider
  error           String?
  metadata        Json?
  createdAt       DateTime @default(now())
  sentAt          DateTime?

  @@index([type])
  @@index([status])
  @@index([createdAt])
}

enum NotificationType {
  EMAIL
  SMS
  WEBHOOK
}

enum NotificationStatus {
  PENDING
  SENT
  FAILED
  BOUNCED
}

// ===================================
// USAGE TRACKING (for rebilling sellers)
// ===================================

model UsageLog {
  id              String   @id @default(cuid())
  sellerId        String
  type            UsageType
  count           Int      @default(1)
  cost            Float    // Base cost
  markup          Float    // Markup amount
  totalCharge     Float    // cost + markup
  billingPeriodStart DateTime
  billingPeriodEnd   DateTime
  metadata        Json?    // e.g., {buyerId, leadId, recipient}
  createdAt       DateTime @default(now())

  seller Seller @relation(fields: [sellerId], references: [id], onDelete: Cascade)

  @@index([sellerId])
  @@index([billingPeriodStart, billingPeriodEnd])
  @@index([type])
}

enum UsageType {
  EMAIL
  SMS
  WEBHOOK
}

// ===================================
// WEBHOOK DELIVERY LOG
// ===================================

model WebhookDelivery {
  id              String   @id @default(cuid())
  buyerId         String
  leadId          String
  url             String
  payload         Json
  status          WebhookStatus @default(PENDING)
  attempts        Int      @default(0)
  lastAttemptAt   DateTime?
  responseStatus  Int?
  responseBody    String?  @db.Text
  error           String?
  createdAt       DateTime @default(now())

  @@index([buyerId])
  @@index([status])
  @@index([createdAt])
}

enum WebhookStatus {
  PENDING
  DELIVERED
  FAILED
  RETRYING
}
